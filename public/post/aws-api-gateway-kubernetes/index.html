<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AWS API Gateway w/ Kubernetes ingress map | Lars Cromley</title>
<link rel="stylesheet" href="https://callmeradical.com/css/style.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/github.min.css">


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://callmeradical.com"><h1 class="title is-4">Lars Cromley</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/callmeradical">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/callmeradical">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h2 class="subtitle is-6">November 15, 2016</h2>
    <h1 class="title">AWS API Gateway w/ Kubernetes ingress map</h1>
    <div class="content">
      <p>Working on large scale unified APIs seems to be a popular trend. Recently I was working with
Microsoft&rsquo;s Graph API, which is their unified API. It is not unreasonable to think that many
different teams contribute to the different resources available; mail, calendars, contacts,
directories. However many resources, the idea is to have all of them referenced from the same
endpoint.</p>

<p>Ideally each team could use whatever language, whatever technology best worked for them. AWS API
Gateway fullfills that easily.</p>

<p><em>Note: This post makes the assumption that you have a functional Kubernetes cluster</em></p>

<p>First we are going to create a new api in Service Gateway.</p>

<pre><code class="language-bash">$ aws apigateway create-rest-api --name demo
$ export API_ID=&lt;created api id&gt;
$ aws apigateway get-resources --rest-api-id=$API_ID
$ export PARENT_ID=&lt;resource id&gt;
$ aws apigateway create-resource \
	--rest-api-id=$API_ID \
	--parent-id=$PARENT_ID \
	--path-part=&quot;health&quot;
$ export HEALTH_ID=&lt;resource id&gt;
$ aws apigateway put-method \
	--rest-api-id=$API_ID \
	--resource-id $HEALTH_ID \
	--http-method GET \
	--authorization-type NONE
</code></pre>

<p>We are going to stop with the API gateway for now, but we will come back to it.</p>

<p>Let&rsquo;s take a look at the app we are going to be running.</p>

<p><a href="https://github.com/callmeradical/healthy">Source Code @ Github</a></p>

<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;log&quot;	
	&quot;net/http&quot;
)

type Response struct {
	Version	string `json:&quot;version&quot;`
	Message string `json:&quot;message&quot;`
}

func healthz(w http.ResponseWriter, r *http.Request) {
	res := Response{
		Version: &quot;v1.0&quot;,
		Message: &quot;We are Healthy!&quot;,
 	}

	str, err := json.MarshalIndent(&amp;res, &quot;&quot;, &quot;\t&quot;)
	if err != nil {
		log.Println(err.Error())
	}

	w.Write(string(str))
}

func main() {
	http.HandleFunc(&quot;/health&quot;, healthz)
	err := http.ListenAndServe(&quot;:8080&quot;, nil)
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}
}
</code></pre>

<p>The app we are going to use is a restful application that responds to a GET on the /health endpoint
on port 8080 and prints &ldquo;We are healthy!&rdquo;</p>

<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    app: healthy
  name: healthy
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: healthy
      name: healthy
    spec:
      containers:
        - name: healthy
          image: &quot;callmeradical/healthy:1.0.0&quot;
---
apiVersion: v1
kind: Service
metadata:
  name: healthy-app
  labels:
    app: healthy
spec:
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app: healthy
</code></pre>

<p>So now this little snippet of yaml will create a deployment in kubernetes and
expose it. Let&rsquo;s go ahead and deploy our app. While we are at it we can verify our
app is in fact actually running and serving traffic.</p>

<p>From the root of the cloned project:</p>

<pre><code class="language-bash">$ kubectl create -f kubernetes/healthy-deployment-svc.yml
$ kubectl get pods
$ kubectl port-forward &lt;name of pod here&gt; 8080:8080
$ curl localhost:8080/health
{
	&quot;version&quot;: &quot;v1.0&quot;,
	&quot;message&quot;: &quot;We are Healthy!&quot;

}
</code></pre>

<blockquote>
<p>A Deployment provides declarative updates for Pods and Replica Sets (the next-generation
Replication Controller). You only need to describe the desired state in a Deployment object,
and the Deployment controller will change the actual state to the desired state at a
controlled rate for you. You can define Deployments to create new resources,
or replace existing ones by new ones.</p>

<p>&ndash; Kubernetes Documentation @ (<a href="http://kubernetes.io/docs/user-guide/deployments/#what-is-a-deployment">http://kubernetes.io/docs/user-guide/deployments/#what-is-a-deployment</a>)</p>
</blockquote>

<p>Now we have our app, a skeleton for API Gateway, but we aren&rsquo;t quite done. We still need to create our
ingress map, our nginx controller, and finish creating the API gateway. Let&rsquo;s start working on deploying
the ingress controller. An ingress controller is a daemon that is deployed as a kubernetes pod. That pod
watches the API server&rsquo;s /ingresses endpoint for updates to the ingress resource. Its job is to satisfy
requests for ingress.</p>

<p>We aren&rsquo;t going to write our controller, as that is out of the scope of this post, but we are going to use
the example controller used on the Kubernetes site, the nginx controller. The nginx controller does the following:</p>

<ul>
<li>Poll until apiserver reports a new ingress</li>
<li>write the nginx config file based on a go text/template</li>
<li>Reload nginx</li>
</ul>

<ol>
<li>Describe Kubernetes ingress map</li>
<li>Create Ingress Nginx/Controller</li>
</ol>

    </div>
  </div>
</section>

<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
      var disqus_shortname = 'callmeradical';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p>&copy; <a href="https://github.com/callmeradical">Lars Cromley</a> 2016</p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/go.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/dockerfile.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-68276982-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>



