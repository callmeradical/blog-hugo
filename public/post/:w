+++
draft = false
date = "2016-11-15T21:10:46-05:00"
title = "AWS API Gateway w/ Kubernetes ingress map"

+++

Working on large scale unified APIs seems to be a popular trend. Recently I was working with 
Microsoft's Graph API, which is their unified API. It is not unreasonable to think that many 
different teams contribute to the different resources available; mail, calendars, contacts, 
directories. However many resources, the idea is to have all of them referenced from the same 
endpoint.

Ideally each team could use whatever language, whatever technology best worked for them. AWS API
Gateway fullfills that easily.

*Note: This post makes the assumption that you have a functional Kubernetes cluster*

First we are going to create a new api in Service Gateway.

```bash
$ aws apigateway create-rest-api --name demo
$ export API_ID=<created api id>
$ aws apigateway get-resources --rest-api-id=$API_ID
$ export PARENT_ID=<resource id>
$ aws apigateway create-resource \
	--rest-api-id=$API_ID \
	--parent-id=$PARENT_ID \
	--path-part="health"
$ export HEALTH_ID=<resource id>
$ aws apigateway put-method \
	--rest-api-id=$API_ID \
	--resource-id $HEALTH_ID \
	--http-method GET \
	--authorization-type NONE
```

We are going to stop with the API gateway for now, but we will come back to it.

Let's take a look at the app we are going to be running.

[Source Code @ Github](https://github.com/callmeradical/healthy)

```go
package main

import (
	"encoding/json"
	"log"	
	"net/http"
)

type Response struct {
	Version	string `json:"version"`
	Message string `json:"message"`
}

func healthz(w http.ResponseWriter, r *http.Request) {
	res := Response{
		Version: "v1.0",
		Message: "We are Healthy!",
 	}

	str, err := json.MarshalIndent(&res, "", "\t")
	if err != nil {
		log.Println(err.Error())
	}

	w.Write(string(str))
}

func main() {
	http.HandleFunc("/health", healthz)
	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}
``` 

The app we are going to use is a restful application that responds to a GET on the /health endpoint
on port 8080 and prints "We are healthy!"

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    app: healthy
  name: healthy
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: healthy
      name: healthy
    spec:
      containers:
        - name: healthy
          image: "callmeradical/healthy:1.0.0"
---
apiVersion: v1
kind: Service
metadata:
  name: healthy-app
  labels:
    app: healthy
spec:
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app: healthy
```

So now this little snippet of yaml will create a deployment in kubernetes and 
expose it. Let's go ahead and deploy our app. While we are at it we can verify our 
app is in fact actually running and serving traffic.	

From the root of the cloned project:

```bash
$ kubectl create -f kubernetes/healthy-deployment-svc.yml
$ kubectl get pods
$ kubectl port-forward <name of pod here> 8080:8080
$ curl localhost:8080/health
{
	"version": "v1.0",
	"message": "We are Healthy!"

}
```

> A Deployment provides declarative updates for Pods and Replica Sets (the next-generation 
> Replication Controller). You only need to describe the desired state in a Deployment object, 
> and the Deployment controller will change the actual state to the desired state at a 
> controlled rate for you. You can define Deployments to create new resources, 
> or replace existing ones by new ones.
>
>   -- Kubernetes Documentation @ (http://kubernetes.io/docs/user-guide/deployments/#what-is-a-deployment)

Now we have our app, a skeleton for API Gateway, but we aren't quite done. We still need to create our 
ingress map, our nginx controller, and finish creating the API gateway. Let's start working on deploying 
the ingress controller. An ingress controller is a daemon that is deployed as a kubernetes pod. That pod 
watches the API server's /ingresses endpoint for updates to the ingress resource. Its job is to satisfy 
requests for ingress.

We aren't going to write our controller, as that is out of the scope of this post, but we are going to use 
the example controller used on the Kubernetes site, the nginx controller. The nginx controller does the following:

- Poll until apiserver reports a new ingress
- write the nginx config file based on a go text/template
- Reload nginx



3. Describe Kubernetes ingress map
4. Create Ingress Nginx/Controller

